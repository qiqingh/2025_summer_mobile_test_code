import subprocess
import time
import logging
from datetime import datetime
import os

# 基础日志记录设置
def setup_logging(exploit_name):
    # 检查是否已存在以 exploit_name 开头的日志目录
    existing_dirs = [d for d in os.listdir() if d.startswith(exploit_name) and os.path.isdir(d)]
    if existing_dirs:
        logging.info(f"Skipping {exploit_name} as it already exists in the output folder.")
        return None, None, None  # 直接返回 None 来表示跳过

    # 创建新的日志文件夹
    timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
    log_dir = f"{exploit_name}_{timestamp}"
    os.makedirs(log_dir, exist_ok=True)
    
    phone_log_filename = os.path.join(log_dir, f"{exploit_name}_phone_log_{timestamp}.log")
    docker_log_dir = os.path.join(log_dir, "docker_logs")
    os.makedirs(docker_log_dir, exist_ok=True)
    
    logging.basicConfig(level=logging.INFO, format='%(asctime)s %(message)s')
    
    return log_dir, phone_log_filename, docker_log_dir

def run_command(command, log_filename):
    command = f"sudo {command}"  # 在命令前加上sudo
    print(f"Running command: {command}")
    logging.info(f"Running command: {command}")
    try:
        result = subprocess.run(command, shell=True, check=True, capture_output=True, text=True)
        with open(log_filename, 'a') as log_file:
            if result.stdout:
                log_file.write(result.stdout)
                logging.info(f"Command output: {result.stdout}")
            if result.stderr:
                log_file.write(result.stderr)
                logging.error(f"Command error: {result.stderr}")
        return result.stdout, result.returncode
    except subprocess.CalledProcessError as e:
        print(f"Command '{command}' failed with error: {e.stderr}")
        logging.error(f"Command '{command}' failed with error: {e.stderr}")
        return None, e.returncode

def run_docker_command(command):
    command = f"sudo {command}"  # 在命令前加上sudo
    result = subprocess.run(command, shell=True, capture_output=True, text=True)
    if result.returncode != 0:
        logging.error(f"Docker command '{command}' failed with return code {result.returncode}. Output: {result.stdout}, Error: {result.stderr}")
    return result.stdout, result.returncode

def swipe(direction, phone_log_filename):
    if direction == "down":
        command = "adb shell input swipe 900 30 900 2000"
    elif direction == "up":
        command = "adb shell input swipe 600 2000 600 100"
    else:
        raise ValueError("Invalid swipe direction")
    
    # 添加这两行来实际执行命令
    run_command(command, phone_log_filename)
    time.sleep(1)  # 可选：添加延迟确保操作完成
        

def click_coordinates(x, y, phone_log_filename):
    command = f"adb shell input tap {x} {y}"
    run_command(command, phone_log_filename)
    time.sleep(1)

def toggle_mode(x, y, phone_log_filename):
    click_coordinates(x, y, phone_log_filename)
    time.sleep(2)

def reboot_phone(phone_log_filename):
    run_command("adb reboot", phone_log_filename)
    run_command("adb wait-for-device", phone_log_filename)
    time.sleep(30)

def wait_for_device(phone_log_filename):
    print("Waiting for device to connect...")
    logging.info("Waiting for device to connect...")
    while True:
        result, _ = run_command("adb get-state", phone_log_filename)
        if result and "device" in result:
            print("Device connected.")
            logging.info("Device connected.")
            break
        time.sleep(0.1)

def start_logging(log_filename):
    run_command("adb logcat -c", log_filename)
    logcat_process = subprocess.Popen(f"sudo adb logcat", stdout=open(log_filename, "a"), stderr=subprocess.STDOUT, shell=True)  # 使用sudo启动日志记录
    return logcat_process

def stop_logging(logcat_process):
    logcat_process.terminate()

def cleanup_docker_container(container_id):
    print("Cleaning up old processes in Docker container...")
    logging.info("Cleaning up old processes in Docker container...")
    command = f"docker exec {container_id} sudo pgrep -f bin/5g_fuzzer"
    result, _ = run_docker_command(command)
    if result:
        pids = result.strip().split('\n')
        for pid in pids:
            command = f"docker exec {container_id} sudo kill {pid}"
            run_docker_command(command)
            print(f"Killed process {pid} in Docker container.")
            logging.info(f"Killed process {pid} in Docker container.")

def send_exploit(exploit_name, container_id):
    # Ensure no previous processes are running
    cleanup_docker_container(container_id)
    
    command = f"docker exec {container_id} sudo bin/5g_fuzzer --EnableSimulator=false --exploit={exploit_name} --MCC=001 --MNC=01 &"
    
    # Use Popen to run the command in the background
    process = subprocess.Popen(command, shell=True)
    logging.info(f"Running Docker command: {command}")
    
    # Wait for the process to start
    time.sleep(8)
    
    return process

def copy_docker_logs(container_id, docker_log_dir):
    # Command to copy logs from Docker container to host
    command = f"docker cp {container_id}:/home/user/wdissector/logs/5gnr_gnb/. {docker_log_dir}/"
    subprocess.run(f"sudo {command}", shell=True)  # 使用sudo复制日志

def get_network_status(phone_log_filename):
    # Check network status using adb commands
    command = "adb shell dumpsys telephony.registry"
    run_command(command, phone_log_filename)

def read_exploit_list(file_path):
    """
    从指定文件读取exploit名称列表
    文件格式：每行一个exploit名称（不带.so扩展名）
    可以包含注释行（以#开头）和空行
    """
    exploit_names = []
    try:
        with open(file_path, 'r') as f:
            for line in f:
                # 去除前后空白
                line = line.strip()
                # 跳过空行和注释行
                if line and not line.startswith('#'):
                    # 如果行中包含.so扩展名，去掉它
                    if line.endswith('.so'):
                        line = line[:-3]
                    exploit_names.append(line)
        logging.info(f"Read {len(exploit_names)} exploit names from {file_path}")
        return exploit_names
    except FileNotFoundError:
        logging.error(f"Exploit list file not found: {file_path}")
        raise
    except Exception as e:
        logging.error(f"Error reading exploit list file: {e}")
        raise

def run_test():
    container_id = "390811db9dd9"  # Docker容器ID
    
    # 硬编码的文件路径 - 请根据实际情况修改
    exploit_list_file = "/home/qiqingh/Desktop/2025_mobile_testing/reproduce/single_field/onePlus13/reproduce_onePlus13_payload_name.txt"
    
    # 从文件读取exploit名称列表
    try:
        exploit_names = read_exploit_list(exploit_list_file)
    except Exception as e:
        print(f"Failed to read exploit list: {e}")
        return
    
    # 如果列表为空，退出
    if not exploit_names:
        print("No exploits found in the list file.")
        logging.warning("No exploits found in the list file.")
        return
    
    print(f"Found {len(exploit_names)} exploits to test.")
    logging.info(f"Found {len(exploit_names)} exploits to test.")

    for exploit_name in exploit_names:
        log_dir, phone_log_filename, docker_log_dir = setup_logging(exploit_name)
        if log_dir is None:
            continue  # 如果日志目录已存在，跳过该exploit

        logging.info(f"Starting test with exploit: {exploit_name}")
        print(f"Starting test with exploit: {exploit_name}")

        # 重启手机
        reboot_phone(phone_log_filename)

        # 等待设备连接
        wait_for_device(phone_log_filename)

        # 连接手机
        toggle_mode(960, 1604, phone_log_filename)  # developer connection

        # 开始记录日志
        logcat_process = start_logging(phone_log_filename)

        # 清理Docker容器内旧进程
        cleanup_docker_container(container_id)

        # 发送EXPLOIT
        send_exploit(exploit_name, container_id)

        # 等待10秒
        # time.sleep(10)

        # 发送exploit并重复开关飞行模式2次
        swipe("down", phone_log_filename)
        # swipe("down", phone_log_filename)
        for j in range(3):
            logging.info(f"Toggling modes, iteration {j + 1}")
            print(f"Toggling modes, iteration {j + 1}")
            toggle_mode(877, 1330, phone_log_filename)  # toggle airplane mode
            get_network_status(phone_log_filename)  # 获取网络状态
            time.sleep(20)  # 等待20秒
            get_network_status(phone_log_filename)  # 获取网络状态
            toggle_mode(877, 1330, phone_log_filename)  # toggle airplane mode
            
        # swipe("up", phone_log_filename)
        swipe("up", phone_log_filename)

        # 停止记录日志
        stop_logging(logcat_process)

        # 复制Docker日志
        copy_docker_logs(container_id, docker_log_dir)

        cleanup_docker_container(container_id)

    print("Test completed.")
    logging.info("Test completed.")

if __name__ == "__main__":
    run_test()